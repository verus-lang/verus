use vir::messages::AstId;

use rustc_hir::HirId;
use rustc_span::SpanData;

use vir::ast::{AutospecUsage, Datatype, Dt, Fun, Function, Krate, Mode, Path, Pattern};
use vir::modes::ErasureModes;

use crate::verus_items::{DummyCaptureItem, VerusItem, VerusItems};
use rustc_hir::def_id::LocalDefId;
use rustc_mir_build_verus::verus::{
    BodyErasure, CallErasure, ExpectSpec, ExpectSpecArgs, NodeErase, VarErasure, VerusErasureCtxt,
    set_verus_erasure_ctxt,
};
use std::collections::HashMap;
use std::sync::Arc;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum CompilableOperator {
    IntIntrinsic,
    Implies,
    RcNew,
    ArcNew,
    BoxNew,
    SmartPtrClone { is_method: bool },
    GhostExec,
    TrackedNew,
    TrackedExec,
    TrackedExecBorrow,
    TrackedGet,
    TrackedBorrow,
    TrackedBorrowMut,
    UseTypeInvariant,
    ClosureToFnProof(Mode),
}

/// Information about each call in the AST (each ExprKind::Call).
#[derive(Clone, Debug, PartialEq, Eq)]
pub enum ResolvedCall {
    /// The call is to a spec or proof function, and should be erased
    Spec,
    /// The call is to a spec or proof function, but may have proof-mode arguments
    SpecAllowProofArgs,
    /// The call is to an operator like == or + that should be compiled.
    CompilableOperator(CompilableOperator),
    /// The call is to a function, and we record the resolved name of the function here.
    Call(Fun, AutospecUsage),
    /// Path and variant of datatype constructor
    Ctor(Path, vir::ast::Ident),
    /// Path and variant of datatype constructor. Used for ExprKind::Struct nodes.
    BracesCtor(Path, vir::ast::Ident, Arc<Vec<vir::ast::Ident>>, bool),
    /// The call is to a dynamically computed function, and is exec
    NonStaticExec,
    /// The call is to a dynamically computed function, and is proof
    NonStaticProof(std::sync::Arc<Vec<Mode>>),
}

#[derive(Clone)]
pub struct ErasureHints {
    /// Copy of the entire VIR crate that was created in the first run's HIR -> VIR transformation
    pub vir_crate: Krate,
    /// Connect expression and pattern HirId to corresponding vir AstId
    pub hir_vir_ids: Vec<(HirId, AstId)>,
    /// Details of each call in the first run's HIR
    pub resolved_calls: Vec<(HirId, SpanData, ResolvedCall)>,
    /// Details of some expressions in first run's HIR
    pub resolved_exprs: Vec<(SpanData, vir::ast::Expr)>,
    /// Details of some patterns in first run's HIR
    pub resolved_pats: Vec<(SpanData, Pattern)>,
    /// Results of mode (spec/proof/exec) inference from first run's VIR
    pub erasure_modes: ErasureModes,
    /// Modes specified directly during rust_to_vir
    pub direct_var_modes: Vec<(HirId, Mode)>,
    /// List of #[verifier(external)] functions.  (These don't appear in vir_crate,
    /// so we need to record them separately here.)
    pub external_functions: Vec<Fun>,
    /// List of function spans ignored by the verifier. These should not be erased
    pub ignored_functions: Vec<(rustc_span::def_id::DefId, SpanData)>,
    pub(crate) bodies: Vec<(LocalDefId, BodyErasure)>,
}

fn mode_to_var_erase(mode: Mode) -> VarErasure {
    match mode {
        Mode::Spec => VarErasure::Erase,
        Mode::Exec | Mode::Proof => VarErasure::Keep,
    }
}

/// Translate ResolvedCall (generated by the rust_verify HIR traversal) to CallErasure,
/// which is what the rustc_mir_build_verus fork expects.
/// REVIEW: it might simpler to skip the ResolvedCall call entirely and have the original
/// traversal generate CallErasure values.
fn resolved_call_to_call_erase(
    functions: &HashMap<Fun, Option<Function>>,
    datatypes: &HashMap<Path, Datatype>,
    resolved_call: &ResolvedCall,
) -> CallErasure {
    match resolved_call {
        ResolvedCall::Spec => CallErasure::EraseTree,
        ResolvedCall::SpecAllowProofArgs => {
            CallErasure::Call(NodeErase::Erase, ExpectSpecArgs::AllPropagate)
        }
        ResolvedCall::Call(f_name, autospec_usage) => {
            if !functions.contains_key(f_name) {
                panic!("internal error: function call to {:?} not found", f_name);
            }
            let f = &functions[f_name];
            let f = if let Some(f) = f {
                f
            } else {
                panic!("internal error: call to external function {:?}", f_name);
            };

            let f = match (autospec_usage, &f.x.attrs.autospec) {
                (AutospecUsage::IfMarked, Some(new_f_name)) => {
                    let f = &functions[new_f_name];
                    let f = if let Some(f) = f {
                        f
                    } else {
                        panic!("internal error: call to external function {:?}", f_name,);
                    };
                    f.clone()
                }
                _ => f.clone(),
            };

            if f.x.mode == Mode::Spec {
                CallErasure::Call(NodeErase::Erase, ExpectSpecArgs::AllYes)
            } else {
                let args =
                    f.x.params
                        .iter()
                        .map(|p| match p.x.mode {
                            Mode::Spec => ExpectSpec::Yes,
                            Mode::Proof | Mode::Exec => ExpectSpec::No,
                        })
                        .collect::<Vec<_>>();
                CallErasure::Call(NodeErase::Keep, ExpectSpecArgs::PerArg(Arc::new(args)))
            }
        }
        ResolvedCall::Ctor(path, variant_name) => {
            let datatype = &datatypes[path];
            let variant = datatype.x.get_variant(variant_name);
            let args = variant
                .fields
                .iter()
                .map(|field| {
                    let (_, field_mode, _) = &field.a;
                    match field_mode {
                        Mode::Spec => ExpectSpec::Yes,
                        Mode::Proof | Mode::Exec => ExpectSpec::Propagate,
                    }
                })
                .collect::<Vec<_>>();
            CallErasure::Call(NodeErase::WhenExpectingSpec, ExpectSpecArgs::PerArg(Arc::new(args)))
        }
        ResolvedCall::BracesCtor(path, variant_name, fields, has_tail) => {
            let datatype = &datatypes[path];
            let variant = datatype.x.get_variant(variant_name);
            let mut args = fields
                .iter()
                .map(|field_name| {
                    let field = vir::ast_util::get_field(&variant.fields, field_name);
                    let (_, field_mode, _) = &field.a;
                    match field_mode {
                        Mode::Spec => ExpectSpec::Yes,
                        Mode::Proof | Mode::Exec => ExpectSpec::Propagate,
                    }
                })
                .collect::<Vec<_>>();
            if *has_tail {
                args.push(ExpectSpec::Propagate);
            }
            CallErasure::Call(NodeErase::WhenExpectingSpec, ExpectSpecArgs::PerArg(Arc::new(args)))
        }
        ResolvedCall::NonStaticExec => CallErasure::keep_all(),
        ResolvedCall::NonStaticProof(modes) => {
            let args = modes
                .iter()
                .map(|mode| match mode {
                    Mode::Spec => ExpectSpec::Yes,
                    Mode::Proof | Mode::Exec => ExpectSpec::No,
                })
                .collect::<Vec<_>>();
            CallErasure::Call(NodeErase::Keep, ExpectSpecArgs::PerArg(Arc::new(args)))
        }
        ResolvedCall::CompilableOperator(co) => match co {
            CompilableOperator::IntIntrinsic => {
                CallErasure::Call(NodeErase::Erase, ExpectSpecArgs::AllPropagate)
            }

            CompilableOperator::GhostExec => CallErasure::EraseTree,

            CompilableOperator::Implies
            | CompilableOperator::RcNew
            | CompilableOperator::ArcNew
            | CompilableOperator::BoxNew
            | CompilableOperator::SmartPtrClone { .. }
            | CompilableOperator::TrackedNew
            | CompilableOperator::TrackedExec => {
                CallErasure::Call(NodeErase::WhenExpectingSpec, ExpectSpecArgs::AllPropagate)
            }

            CompilableOperator::ClosureToFnProof(_)
            | CompilableOperator::TrackedExecBorrow
            | CompilableOperator::TrackedGet
            | CompilableOperator::TrackedBorrow
            | CompilableOperator::TrackedBorrowMut
            | CompilableOperator::UseTypeInvariant => CallErasure::keep_all(),
        },
    }
}

pub(crate) fn setup_verus_ctxt_for_thir_erasure(
    verus_items: &VerusItems,
    erasure_hints: &ErasureHints,
) {
    let mut id_to_hir: HashMap<AstId, Vec<HirId>> = HashMap::new();
    for (hir_id, vir_id) in &erasure_hints.hir_vir_ids {
        if !id_to_hir.contains_key(vir_id) {
            id_to_hir.insert(*vir_id, vec![]);
        }
        id_to_hir.get_mut(vir_id).unwrap().push(*hir_id);
    }

    let mut vars = HashMap::<HirId, VarErasure>::new();
    for (span, mode) in erasure_hints.erasure_modes.var_modes.iter() {
        if crate::spans::from_raw_span(&span.raw_span).is_none() {
            continue;
        }
        if !id_to_hir.contains_key(&span.id) {
            dbg!(span);
            dbg!(mode);
        }
        for hir_id in &id_to_hir[&span.id] {
            vars.insert(*hir_id, mode_to_var_erase(*mode));
        }
    }

    let mut functions = HashMap::<Fun, Option<Function>>::new();
    for f in &erasure_hints.vir_crate.functions {
        functions.insert(f.x.name.clone(), Some(f.clone())).map(|_| panic!("{:?}", &f.x.name));
    }

    let mut datatypes = HashMap::<Path, Datatype>::new();
    for d in &erasure_hints.vir_crate.datatypes {
        if let Dt::Path(path) = &d.x.name {
            datatypes.insert(path.clone(), d.clone()).map(|_| panic!("{:?}", &path));
        }
    }

    let mut calls = HashMap::<HirId, CallErasure>::new();
    for (hir_id, _, resolved_call) in &erasure_hints.resolved_calls {
        calls.insert(*hir_id, resolved_call_to_call_erase(&functions, &datatypes, resolved_call));
    }

    let mut bodies = HashMap::<LocalDefId, BodyErasure>::new();
    for (hir_id, c) in &erasure_hints.bodies {
        bodies.insert(*hir_id, *c);
    }

    let mut condition_spec = HashMap::<HirId, bool>::new();
    for (span, mode) in &erasure_hints.erasure_modes.condition_modes {
        let spec = matches!(mode, Mode::Spec);
        if crate::spans::from_raw_span(&span.raw_span).is_none() {
            continue;
        }
        if !id_to_hir.contains_key(&span.id) {
            dbg!(span, span.id);
            panic!("missing id_to_hir");
        }
        for hir_id in &id_to_hir[&span.id] {
            if condition_spec.contains_key(hir_id) {
                if condition_spec[hir_id] != spec {
                    panic!("inconsistent condition_modes: {:?}", span);
                }
            } else {
                condition_spec.insert(*hir_id, spec);
            }
        }
    }

    let verus_erasure_ctxt = VerusErasureCtxt {
        vars,
        calls,
        bodies,

        condition_spec,

        erased_ghost_value_fn_def_id: *verus_items
            .name_to_id
            .get(&VerusItem::ErasedGhostValue)
            .unwrap(),
        dummy_capture_struct_def_id: *verus_items
            .name_to_id
            .get(&VerusItem::DummyCapture(DummyCaptureItem::Struct))
            .unwrap(),
    };
    set_verus_erasure_ctxt(Arc::new(verus_erasure_ctxt));
}
